<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot – mm固定 + 可変移動平均</title>
<style>
  :root{ --h:60vh }
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;margin:16px}
  h1{margin:0 0 8px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:10px 0}
  .row>*{height:32px}
  button{padding:6px 10px}
  input[type="number"]{width:84px;padding:4px 6px}
  #status{font-weight:700;margin-left:10px}
  #wrap{width:100%;height:var(--h);border:1px solid #ddd;border-radius:8px;background:#fff;overflow:hidden}
  canvas{width:100%;height:100%;display:block}
  #log{margin-top:8px;color:#444;white-space:pre-wrap;font-family:ui-monospace,monospace;font-size:12px;
       max-height:28vh;overflow:auto;border:1px solid #eee;padding:6px;border-radius:6px;background:#fafafa}
  label span{opacity:.7;margin-right:4px}
</style>
</head>
<body>
<h1>VL53L0X Live Plot <small>mm固定 + 可変移動平均</small></h1>

<div class="row">
  <button id="btnConnect">Connect</button>
  <button id="btnDisconnect">Disconnect</button>
  <label><span>Hz</span>
    <input id="hzNum" type="number" value="50" min="1" max="50">
  </label>
  <button id="btnStart">Start</button>
  <button id="btnStop">Stop</button>
  <button id="btnReset">Reset</button>
  <button id="btnCsv">CSV</button>

  <label><span>MA点数</span>
    <input id="maNum" type="number" value="1" min="1" max="50" title="移動平均の点数 (1=生データ)">
  </label>
  <span id="status">STOP</span>
</div>

<div id="wrap"><canvas id="cv"></canvas></div>
<pre id="log"></pre>

<script>
// --------- 簡易ログ ----------
const logEl = document.getElementById('log');
function log(...args){ const s=args.map(a=>typeof a==='object'?JSON.stringify(a):String(a)).join(' ');
  logEl.textContent+=s+"\n"; logEl.scrollTop=logEl.scrollHeight; }
function setStatus(s){ document.getElementById('status').textContent=s; }
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

// --------- 要素 ----------
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const hzNum=document.getElementById('hzNum');
const maNum=document.getElementById('maNum');
const btnConnect=document.getElementById('btnConnect');
const btnDisconnect=document.getElementById('btnDisconnect');
const btnStart=document.getElementById('btnStart');
const btnStop=document.getElementById('btnStop');
const btnReset=document.getElementById('btnReset');
const btnCsv=document.getElementById('btnCsv');

// --------- 状態 ----------
let port=null, reader=null, writer=null, reading=false;
const rec=[];            // {t, cm}（描画用：フィルタ後）
const rawRec=[];         // {t, cmRaw}（生）
let yMax=100, xMax=10;
let t0_ms=null;

// 移動平均用バッファ
let maN=1, maQ=[], maSum=0;

// --------- Canvas ----------
const pad={l:56,r:14,t:12,b:28};
function cssW(){return cv.getBoundingClientRect().width;}
function cssH(){return cv.getBoundingClientRect().height;}
function x2px(x){ const w=cssW()-pad.l-pad.r; return pad.l + (x/xMax)*w; }
function y2px(y){ const h=cssH()-pad.t-pad.b; return pad.t + (1-y/yMax)*h; }
function fitCanvas(){
  const r=cv.getBoundingClientRect(); const ratio=window.devicePixelRatio||1;
  cv.width=Math.max(1,Math.floor(r.width*ratio)); cv.height=Math.max(1,Math.floor(r.height*ratio));
  ctx.setTransform(1,0,0,1,0,0); ctx.scale(ratio,ratio); draw();
}
window.addEventListener('resize', fitCanvas);

function drawAxes(){
  const w=cssW(), h=cssH();
  ctx.clearRect(0,0,w,h); ctx.fillStyle="#fff"; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
  const yStep=Math.max(10, Math.round(yMax/10/10)*10 || 10);
  for(let y=0;y<=yMax;y+=yStep){ const py=y2px(y);
    ctx.beginPath(); ctx.moveTo(pad.l,py); ctx.lineTo(w-pad.r,py); ctx.stroke();
    ctx.fillStyle="#666"; ctx.font="12px system-ui"; ctx.fillText(String(y),6,py+4); }
  const xStep=Math.max(1, Math.round(xMax/10)||1);
  for(let x=0;x<=xMax;x+=xStep){ const px=x2px(x);
    ctx.beginPath(); ctx.moveTo(px,pad.t); ctx.lineTo(px,h-pad.b); ctx.stroke(); }
  ctx.fillStyle="#111"; ctx.font="12px system-ui"; ctx.fillText("Distance [cm]",6,14);
  ctx.fillText("Time [s]", w-56, h-6);
}
function draw(){
  drawAxes(); if(rec.length<2) return;
  ctx.strokeStyle="#1f77b4"; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(x2px(rec[0].t), y2px(rec[0].cm));
  for(let i=1;i<rec.length;i++){ const r=rec[i]; ctx.lineTo(x2px(r.t), y2px(r.cm)); }
  ctx.stroke();
}
let rafId=null; function scheduleDraw(){ if(rafId) return; rafId=requestAnimationFrame(()=>{rafId=null; draw();}); }
function resetPlotOnly(){
  rec.length=0; rawRec.length=0; maQ=[]; maSum=0;
  yMax=100; xMax=10; t0_ms=null; scheduleDraw();
}
function updateAxes(t,cm){ if(cm>yMax) yMax=Math.ceil(cm/50)*50; if(t>xMax) xMax=Math.ceil(t/10)*10; }

// --------- 送受信 ----------
async function sendLine(s){ if(!writer) return; log('> ', s); await writer.write(new TextEncoder().encode(s+"\n")); }
class LineBreakTransformer{
  constructor(){ this.container=""; this.count=0; }
  transform(chunk,controller){
    this.container+=chunk; const lines=this.container.split(/\r?\n/); this.container=lines.pop();
    for(const l of lines){ if(this.count<20){ log('[RX]',l); this.count++; } controller.enqueue(l); }
  }
  flush(controller){ if(this.container){ controller.enqueue(this.container); this.container=""; } }
}

// --------- 行パース（常に mm → cm） ----------
function handleLine(line){
  const s=line.trim();
  if(/^#\s*start/i.test(s)){ setStatus('RUN'); return; }
  if(/^#\s*stop/i.test(s)){ setStatus('STOP'); return; }
  if(/^#/.test(s)) return;

  // CSV "t_ms,dist_mm" 専用パーサ
  const m = s.match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/);
  if(!m) return;

  const t_ms=parseFloat(m[1]); const dist_mm=parseFloat(m[2]);
  if(!isFinite(t_ms)||!isFinite(dist_mm)) return;

  if(t0_ms===null) t0_ms=t_ms;
  const t=(t_ms - t0_ms)/1000;                  // X軸：デバイスの時刻[s]
  const cmRaw = dist_mm / 10;                   // ★ここを常に mm→cm に固定

  rawRec.push({t, cmRaw});

  // 可変移動平均（1なら生値）
  maN = Math.max(1, Math.min(50, Number(maNum.value)||1));
  maQ.push(cmRaw); maSum += cmRaw;
  if(maQ.length > maN){ maSum -= maQ.shift(); }
  const cm = (maN>1) ? (maSum / maQ.length) : cmRaw;

  // 異常値の簡易除外（0<cm<4000）
  if(cm>0 && cm<4000){
    rec.push({t,cm}); updateAxes(t,cm); scheduleDraw();
  }
}

// --------- UIイベント ----------
btnConnect.addEventListener('click', async ()=>{
  try{
    if(!('serial' in navigator)) { alert('Web Serial未対応'); return; }
    log('Connect: requestPort...'); port = await navigator.serial.requestPort();
    log('Port selected. Opening...'); await port.open({baudRate:115200});
    writer=port.writable.getWriter(); setStatus('CONNECTED'); log('Opened. baud=115200');
  }catch(e){ log('Connect失敗:',e?.message??e); alert('Serial接続に失敗: '+e); }
});

btnDisconnect.addEventListener('click', async ()=>{
  try{ await sendLine('STOP'); }catch(_){}
  try{ reading=false; if(reader) await reader.cancel(); }catch(_){}
  try{ if(writer){ writer.releaseLock(); writer=null; } }catch(_){}
  try{ if(port){ await port.close(); } }catch(_){}
  port=null; setStatus('DISCONNECTED'); log('Disconnected.');
});

btnStart.addEventListener('click', async ()=>{
  if(!port){ alert('先にConnectしてください'); return; }
  const hz = Math.max(1, Math.min(50, Number(hzNum.value)||50));
  resetPlotOnly();
  try{
    await sendLine(`RATE hz=${hz}`); await sleep(50);
    await sendLine(`START hz=${hz}`);
    if(reading) return; reading=true; setStatus('RUN');

    const decoder=new TextDecoderStream();
    const piping=port.readable.pipeTo(decoder.writable).catch(()=>{});
    const lineStream=decoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer()));
    reader=lineStream.getReader();
    (async()=>{
      try{
        for(;;){ const {value,done}=await reader.read(); if(done||!reading) break;
          if(value!==undefined) handleLine(value); }
      }catch(err){ log('reader loop err:',err); }
      finally{ try{ reader.releaseLock(); }catch(_){}
        await piping.catch(()=>{}); log('reader loop end'); }
    })();
  }catch(e){ log('Start失敗:',e); alert('Start処理で失敗: '+e); }
});

btnStop.addEventListener('click', async ()=>{
  try{ await sendLine('STOP'); }catch(_){}
  try{ reading=false; if(reader) await reader.cancel(); }catch(_){}
  setStatus('STOP'); log('STOP sent.');
});

btnReset.addEventListener('click', ()=>{
  resetPlotOnly(); setStatus(reading?'RUN (RESET)':'RESET'); log('Plot reset.');
});

btnCsv.addEventListener('click', ()=>{
  let csv="t_sec,cm\n";
  for(const r of rec){ csv += `${r.t.toFixed(3)},${r.cm.toFixed(3)}\n`; }
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='vl53l0x_log.csv'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url); log('CSV downloaded. samples=',rec.length);
});

// 初期化
fitCanvas(); resetPlotOnly(); draw();
log('Ready. 受信は CSV: "t_ms,dist_mm" 前提。距離は mm→cm に固定変換します。移動平均は「MA点数」で変更(1=オフ)。');
</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot</title>
<!-- favicon 404回避 -->
<link rel="icon" href="data:,">
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
  h1 { margin: 0 0 12px; font-size: 28px; }
  .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  .toolbar input { width:90px; padding:4px 6px; }
  .toolbar button { padding:6px 10px; }
  #status { margin-left: 8px; font-weight: 600; }
  #chartWrap { width:100%; height: 520px; }
  canvas { width:100% !important; height:100% !important; }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body>
  <h1>VL53L0X Live Plot</h1>
  <div class="toolbar">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>
    Hz: <input id="hzNum" type="number" min="1" max="50" step="1" value="50">
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <button id="btnReset">Reset</button>
    Known(cm): <input id="knownCm" type="number" min="1" max="400" value="10">
    <button id="btnCal">Calibrate</button>
    <button id="btnCsv">CSV</button>
    <span id="status">STOPPED</span>
  </div>

  <div id="chartWrap"><canvas id="chart"></canvas></div>

<script>
(() => {
  // ====== Chart.js 初期化 ======
  const ctx = document.getElementById('chart');
  const data = { labels: [], datasets: [{ label: 'Distance [cm]', data: [], tension: 0, pointRadius: 0 }] };
  const yInitialMax = 100;   // 初期 100cm
  let xWindow = 10;          // 初期 10s（超えたら自動拡張）
  const chart = new Chart(ctx, {
    type: 'line',
    data,
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Time [s]' },
          min: 0, max: xWindow
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Distance [cm]' },
          suggestedMin: 0,
          suggestedMax: yInitialMax
        }
      },
      plugins: { legend: { display: false } }
    }
  });

  function pushPoint(tSec, cm) {
    // あり得ない値は捨てる（保険。FW側でも除外済み）
    if (!(isFinite(cm) && cm >= 0 && cm <= 400)) return;

    data.datasets[0].data.push({ x: tSec, y: cm });

    // Y軸: 100cm以上が来たら上限を50刻みで引き上げ
    const yMaxNow = chart.options.scales.y.suggestedMax ?? yInitialMax;
    if (cm > yMaxNow) {
      chart.options.scales.y.suggestedMax = Math.ceil(cm / 50) * 50;
    }

    // X軸: 全履歴を見せるため、10s, 20s, 30s…と自動拡張
    if (tSec > xWindow) {
      xWindow = Math.ceil(tSec / 10) * 10;
      chart.options.scales.x.max = xWindow;
    }

    chart.update();
  }

  // ====== CSV ======
  const records = []; // {t_ms, mm}
  function toCSV(rows) {
    const header = 't_ms,mm,cm\n';
    return header + rows.map(r => `${r.t},${r.mm},${(r.mm/10).toFixed(1)}`).join('\n') + '\n';
  }

  // ====== Web Serial ======
  let port = null, reader = null, writer = null, reading = false;
  const hzNum = document.getElementById('hzNum');
  const statusEl = document.getElementById('status');

  async function sendLine(line) {
    if (!writer) return;
    const msg = new TextEncoder().encode(line.trim() + '\n');
    await writer.write(msg);
  }

  // 行区切りで読む
  async function startReading() {
    if (!port) return;
    const textDecoder = new TextDecoderStream();
    const readableClosed = port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();

    let buf = '';
    reading = true;
    while (reading) {
      const { value, done } = await reader.read();
      if (done) break;
      buf += value;
      let idx;
      while ((idx = buf.indexOf('\n')) >= 0) {
        const line = buf.slice(0, idx).trim();
        buf = buf.slice(idx + 1);
        handleLine(line);
      }
    }
  }

  function handleLine(line) {
    if (!line) return;

    if (line.startsWith('#')) { // ステータス
      statusEl.textContent = line.slice(1).trim().toUpperCase();
      return;
    }

    // データ: "ms,mm"
    const parts = line.split(',');
    if (parts.length < 2) return;
    const t_ms = Number(parts[0]);
    const mm   = Number(parts[1]);
    if (!isFinite(t_ms) || !isFinite(mm)) return;
    if (mm <= 0 || mm >= 4000) return;   // 0/8190/8191/4000以上は捨てる（保険）

    records.push({ t: t_ms, mm });
    pushPoint(t_ms/1000, mm/10);
  }

  // ====== UI ======
  const $ = id => document.getElementById(id);

  $('btnConnect').addEventListener('click', async () => {
    try {
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });
      writer = port.writable.getWriter();
      statusEl.textContent = 'CONNECTED';
      // FWからの "# READY" を受け取るために読み取り開始
      startReading();
    } catch(e) {
      alert('Serial接続に失敗: ' + e);
    }
  });

  $('btnDisconnect').addEventListener('click', async () => {
    try { await sendLine('STOP'); } catch {}
    reading = false;
    try { if (reader) await reader.cancel(); } catch {}
    try { if (writer) { writer.releaseLock(); writer = null; } } catch {}
    try { if (port) await port.close(); } catch {}
    port = null;
    statusEl.textContent = 'DISCONNECTED';
  });

  $('btnStart').addEventListener('click', async () => {
    if (!port) { alert('先にConnectしてください'); return; }
    const hz = Number(hzNum.value) || 50;
    await sendLine(`START hz=${hz}`);
    statusEl.textContent = 'STARTING...';
  });

  $('btnStop').addEventListener('click', async () => {
    await sendLine('STOP');
    statusEl.textContent = 'STOPPED';
  });

  $('btnReset').addEventListener('click', async () => {
    // 画面側のリセット
    data.datasets[0].data.length = 0;
    records.length = 0;
    chart.options.scales.x.min = 0;
    xWindow = 10;
    chart.options.scales.x.max = xWindow;
    chart.options.scales.y.suggestedMax = yInitialMax;
    chart.update();

    // センサー再初期化
    try { await sendLine('RESET'); } catch {}
    statusEl.textContent = 'RESET';
  });

  $('btnCal').addEventListener('click', async () => {
    const known = Number($('knownCm').value) || 10;
    await sendLine(`CAL cm=${known}`);
  });

  $('btnCsv').addEventListener('click', () => {
    const csv = toCSV(records);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'vl53l0x_log.csv';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // Feature detection
  if (!('serial' in navigator)) {
    alert('このブラウザはWeb Serialに対応していません。Chrome/Edgeの最新をHTTPSでお使いください。');
  }
})();
</script>
</body>
</html>

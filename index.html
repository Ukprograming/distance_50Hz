<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<title>VL53L0X WebSerial Logger</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 16px; }
  button, input { margin: 4px; }
  #log { height: 220px; overflow: auto; background: #f6f7f9; padding: 8px; border: 1px solid #ddd; }
</style>
<body>
<h1>VL53L0X Logger</h1>
<div>
  <button id="btnConnect">Connect</button>
  <button id="btnDisconnect" disabled>Disconnect</button>
</div>
<div>
  Hz: <input id="hzNum" type="number" min="1" max="50" value="50" />
  <button id="btnStart" disabled>Start</button>
  <button id="btnStop"  disabled>Stop</button>
  <button id="btnCsv"   disabled>CSV</button>
</div>
<div>Latest: <span id="latest">-</span> mm</div>
<pre id="log"></pre>

<script>
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnCsv = document.getElementById('btnCsv');
  const hzNum = document.getElementById('hzNum');
  const latest = document.getElementById('latest');
  const log = document.getElementById('log');

  let port = null;
  let reader = null;
  let writer = null;
  let reading = false;
  const records = []; // {t, mm}

  function logLine(s) {
    log.textContent += s + '\n';
    log.scrollTop = log.scrollHeight;
  }

  async function sendLine(s) {
    if (!writer) {
      writer = port.writable.getWriter();
    }
    const data = new TextEncoder().encode(s + '\n');
    await writer.write(data);
    logLine('> ' + s);
  }

  async function startReading() {
    reading = true;
    const textDecoder = new TextDecoderStream();
    const readable = port.readable.pipeThrough(textDecoder);

    // 行ごとに区切る
    let buffer = '';
    const transform = new TransformStream({
      transform(chunk, controller) {
        buffer += chunk;
        const lines = buffer.split(/\r?\n/);
        buffer = lines.pop();
        for (const line of lines) controller.enqueue(line);
      }
    });

    reader = readable.pipeThrough(transform).getReader();

    try {
      while (reading) {
        const { value, done } = await reader.read();
        if (done) break;
        if (!value) continue;

        // Arduino 側は1行に距離(mm) or #コメントを出す
        if (value.startsWith('#')) {
          logLine(value);
          continue;
        }
        const mm = Number(value.trim());
        if (Number.isFinite(mm)) {
          records.push({ t: Date.now(), mm });
          if (records.length > 5000) records.shift();
          latest.textContent = mm;
          logLine(String(mm));
        } else {
          logLine(value);
        }
      }
    } catch (e) {
      console.error(e);
    } finally {
      if (reader) {
        try { await reader.cancel(); } catch {}
        reader.releaseLock();
        reader = null;
      }
    }
  }

  function toCSV(rows) {
    const header = 'timestamp(ms),distance(mm)\n';
    const body = rows.map(r => `${r.t},${r.mm}`).join('\n');
    return header + body + '\n';
  }

  // UI handlers
  btnConnect.addEventListener('click', async () => {
    try {
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;
      btnStart.disabled = false;
      btnStop.disabled = false;
      btnCsv.disabled = false;
      logLine('# Connected');
    } catch (e) {
      alert('Serial接続に失敗: ' + e);
    }
  });

  btnDisconnect.addEventListener('click', async () => {
    try { await sendLine('STOP'); } catch {}
    reading = false;
    try { if (reader) await reader.cancel(); } catch {}
    try {
      if (writer) { writer.releaseLock(); writer = null; }
    } catch {}
    try { if (port) await port.close(); } catch {}
    port = null;

    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
    btnStart.disabled = true;
    btnStop.disabled = true;
    btnCsv.disabled = true;
    logLine('# Disconnected');
  });

  btnStart.addEventListener('click', async () => {
    if (!port) { alert('先にConnectしてください'); return; }
    const hz = Number(hzNum.value) || 50;
    await sendLine(`START hz=${hz}`);
    startReading();
  });

  btnStop.addEventListener('click', async () => {
    await sendLine('STOP');
    reading = false;
  });

  btnCsv.addEventListener('click', () => {
    const csv = toCSV(records);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'vl53l0x_log.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  // Feature detection
  if (!('serial' in navigator)) {
    alert('このブラウザはWeb Serialに対応していません。デスクトップ版の Chrome / Edge を、HTTPS もしくは http://localhost でお試しください。');
  }
</script>
</body>
</html>

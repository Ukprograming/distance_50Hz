<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot</title>

<!-- 同梱したChart.jsを読み込み（CDNは使いません） -->
<script src="./chart.umd.min.js"></script>

<style>
  :root{--h:60vh}
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;margin:16px}
  h1{margin:0 0 8px}
  small{color:#666}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:10px 0}
  .row>*{height:32px}
  input[type="number"]{width:84px;padding:4px 6px}
  select{height:32px}
  button{padding:6px 10px}
  #status{font-weight:700;margin-left:10px}
  #chartWrap{width:100%;height:var(--h)}
  canvas{width:100%!important;height:100%!important}
</style>
</head>
<body>
  <h1>VL53L0X Live Plot <small>build: v3-local</small></h1>

  <div class="row">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>

    <label>Hz:
      <input id="hzNum" type="number" value="50" min="1" max="50">
    </label>

    <label>MA N:
      <input id="maNum" type="number" value="5" min="1" max="50" step="1">
    </label>

    <label>表示:
      <select id="modeSel">
        <option value="ma" selected>MAのみ</option>
        <option value="raw">RAWのみ</option>
        <option value="both">両方</option>
      </select>
    </label>

    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <button id="btnReset">Reset</button>
    <button id="btnCsv">CSV</button>

    <span id="status">STOP</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart"></canvas>
  </div>

<script>
/* ======= 早期チェック ======= */
if(!('serial' in navigator)){
  alert('このブラウザはWeb Serialに対応していません。Chrome/EdgeをHTTPSでお使いください。');
}
if(!window.Chart){
  alert('同梱の chart.umd.min.js を読み込めませんでした。配置場所やファイル名を確認してください。');
  throw new Error('Chart.js not loaded');
}

/* ======= 参照取得 ======= */
const el = (id)=>document.getElementById(id);
const btnConnect=el('btnConnect'), btnDisconnect=el('btnDisconnect');
const btnStart=el('btnStart'), btnStop=el('btnStop'), btnReset=el('btnReset');
const btnCsv=el('btnCsv'), hzNum=el('hzNum'), maNum=el('maNum'), modeSel=el('modeSel'), statusEl=el('status');

/* ======= 状態 ======= */
let port=null, reader=null, writer=null, reading=false;
let t0=0;
const rec=[]; // {t,raw,ma}
let yMax=100, xMax=10;
let maN=5, maBuf=[];

/* ======= Chart.js 準備 ======= */
function makeChart(){
  const ctx = el('chart').getContext('2d');
  const datasetRaw={label:'RAW (cm)',data:[],borderWidth:1.5,pointRadius:0,tension:0};
  const datasetMA ={label:`MA${maN} (cm)`,data:[],borderWidth:2,pointRadius:0,tension:0};
  const chart=new Chart(ctx,{
    type:'line',
    data:{datasets:[datasetMA,datasetRaw]},
    options:{
      animation:false,responsive:true,maintainAspectRatio:false,parsing:false,
      scales:{x:{type:'linear',title:{display:true,text:'Time [s]'},min:0,max:xMax},
              y:{title:{display:true,text:'Distance [cm]'},min:0,max:yMax}},
      plugins:{legend:{display:true}}
    }
  });
  return {chart,datasetRaw,datasetMA};
}
const {chart,datasetRaw,datasetMA}=makeChart();

function setMode(){
  const v=modeSel.value;
  datasetMA.hidden = (v==='raw');
  datasetRaw.hidden= (v==='ma');
  chart.update();
}

/* ======= グラフ＆MA ======= */
function resetPlotOnly(){
  rec.length=0; datasetRaw.data.length=0; datasetMA.data.length=0; maBuf.length=0;
  yMax=100; xMax=10;
  chart.options.scales.y.max=yMax; chart.options.scales.x.max=xMax;
  datasetMA.label=`MA${maN} (cm)`;
  t0=performance.now();
  chart.update();
}
function updateAxes(t,cm){
  if(cm>yMax){ yMax=Math.ceil(cm/50)*50; chart.options.scales.y.max=yMax; }
  if(t>xMax){ xMax=Math.ceil(t/10)*10;   chart.options.scales.x.max=xMax; }
}
function addPoint(t,raw,ma){
  datasetRaw.data.push({x:t,y:raw});
  datasetMA.data.push({x:t,y:ma});
  chart.update('none');
}
function sma(v){
  maBuf.push(v); if(maBuf.length>maN) maBuf.shift();
  let s=0; for(let i=0;i<maBuf.length;i++) s+=maBuf[i];
  return s/maBuf.length;
}
function recomputeMA(){
  maBuf.length=0;
  datasetMA.data.length=0;
  for(const r of rec){ r.ma=sma(r.raw); datasetMA.data.push({x:r.t,y:r.ma}); }
  datasetMA.label=`MA${maN} (cm)`; chart.update();
}

/* ======= Web Serial ======= */
function setStatus(s){ statusEl.textContent=s; }

async function sendLine(s){
  if(!writer) return;
  await writer.write(new TextEncoder().encode(s+"\n"));
}

class LineBreakTransformer{
  constructor(){ this.container=""; }
  transform(chunk,controller){
    this.container+=chunk;
    const lines=this.container.split(/\r?\n/);
    this.container=lines.pop();
    for(const line of lines) controller.enqueue(line);
  }
  flush(controller){ if(this.container) controller.enqueue(this.container); }
}

function handleLine(line){
  const s=line.trim();
  // 数字の行だけ採用（mm）
  if(!/^-?\d+(\.\d+)?$/.test(s)) return;
  const mm=Number(s);
  if(!isFinite(mm) || mm<0 || mm>4000) return;
  const cm=mm/10;
  const t=(performance.now()-t0)/1000;
  const ma=sma(cm);
  rec.push({t,raw:cm,ma});
  updateAxes(t,cm);
  addPoint(t,cm,ma);
}

async function startReading(){
  if(!port || reading) return;
  reading=true; setStatus('RUN');
  t0=performance.now();
  const decoder=new TextDecoderStream();
  const piping=port.readable.pipeTo(decoder.writable).catch(()=>{});
  const lineStream=decoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer()));
  reader=lineStream.getReader();
  try{
    while(reading){
      const {value,done}=await reader.read();
      if(done || !reading) break;
      if(value!==undefined) handleLine(value);
    }
  }catch(_){}
  finally{
    try{ reader.releaseLock(); }catch(_){}
    await piping.catch(()=>{});
  }
}
async function stopReading(){
  reading=false;
  try{ if(reader) await reader.cancel(); }catch(_){}
  setStatus('STOP');
}

/* ======= イベント ======= */
btnConnect.addEventListener('click', async ()=>{
  try{
    port=await navigator.serial.requestPort();
    await port.open({baudRate:115200});
    writer=port.writable.getWriter();
    setStatus('CONNECTED');
  }catch(e){ alert('Serial接続に失敗: '+e); }
});
btnDisconnect.addEventListener('click', async ()=>{
  try{ await sendLine('STOP'); }catch(_){}
  await stopReading();
  try{ if(writer){ writer.releaseLock(); writer=null; } }catch(_){}
  try{ if(port) await port.close(); }catch(_){}
  port=null; setStatus('DISCONNECTED');
});
btnStart.addEventListener('click', async ()=>{
  if(!port){ alert('先にConnectしてください'); return; }
  const hz=Math.max(1,Math.min(50, Number(hzNum.value)||50));
  resetPlotOnly();
  await sendLine(`START hz=${hz}`);
  startReading();
});
btnStop.addEventListener('click', async ()=>{
  await sendLine('STOP'); await stopReading();
});
btnReset.addEventListener('click', ()=>{
  resetPlotOnly(); setStatus(reading ? 'RUN (RESET)' : 'RESET');
});
btnCsv.addEventListener('click', ()=>{
  let csv="t_sec,raw_cm,ma_cm\n";
  for(const r of rec){ csv+=`${r.t.toFixed(3)},${r.raw.toFixed(3)},${r.ma.toFixed(3)}\n`; }
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='vl53l0x_log.csv';
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});
maNum.addEventListener('change', ()=>{
  const n=Math.max(1,Math.min(50, Number(maNum.value)||5));
  maN=n; maNum.value=n; recomputeMA();
});
modeSel.addEventListener('change', setMode);

/* 初期設定 */
setMode();
resetPlotOnly();
</script>
</body>
</html>

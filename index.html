<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VL53L0X Live Plot</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;margin:16px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:10px}
  .row>*{height:32px}
  input[type="number"]{width:80px;padding:4px 6px}
  select{height:32px}
  button{padding:6px 10px}
  #status{font-weight:700;margin-left:8px}
  #chartWrap{width:100%;height:62vh}
  canvas{width:100%!important;height:100%!important}
</style>
</head>
<body>
  <h1>VL53L0X Live Plot</h1>

  <div class="row">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>

    <label>Hz:
      <input id="hzNum" type="number" value="50" min="1" max="50">
    </label>

    <label>MA N:
      <input id="maNum" type="number" value="5" min="1" max="50" step="1" />
    </label>

    <label>表示:
      <select id="modeSel">
        <option value="ma">移動平均のみ</option>
        <option value="raw">生データのみ</option>
        <option value="both">両方</option>
      </select>
    </label>

    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <button id="btnReset">Reset</button>
    <button id="btnCsv">CSV</button>

    <span id="status">STOP</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart"></canvas>
  </div>

<script>
/* ====================== 状態変数 ====================== */
let port=null, reader=null, writer=null, reading=false;
let t0=0;
const records=[];   // {t:sec, raw:cm, ma:cm}
let yMax=100;       // Y軸初期上限 100cm
let xMax=10;        // X軸初期上限 10s
let maN=5;          // 移動平均点数
let maBuf=[];       // MA用リングバッファ

/* ====================== Chart.js 準備 ====================== */
const ctx=document.getElementById('chart').getContext('2d');
const datasetRaw={
  label:'RAW (cm)',
  data:[],                  // {x,y}
  borderWidth:1.5,
  pointRadius:0,
  tension:0
};
const datasetMA={
  label:`MA${maN} (cm)`,
  data:[],
  borderWidth:2,
  pointRadius:0,
  tension:0
};
const chart=new Chart(ctx,{
  type:'line',
  data:{datasets:[datasetMA,datasetRaw]}, // デフォルトはMAのみ表示
  options:{
    animation:false,
    responsive:true,
    maintainAspectRatio:false,
    parsing:false, // {x,y}オブジェクトをそのまま使う
    scales:{
      x:{type:'linear',title:{display:true,text:'Time [s]'},min:0,max:xMax},
      y:{title:{display:true,text:'Distance [cm]'},min:0,max:yMax}
    },
    plugins:{
      legend:{display:true},
      decimation:{enabled:false}
    }
  }
});
function applyMode(){
  const mode=document.getElementById('modeSel').value;
  if(mode==='ma'){ datasetMA.hidden=false; datasetRaw.hidden=true; }
  else if(mode==='raw'){ datasetMA.hidden=true; datasetRaw.hidden=false; }
  else { datasetMA.hidden=false; datasetRaw.hidden=false; }
  chart.update();
}
function updateAxesIfNeeded(t,cm){
  if(cm>yMax){ yMax=Math.ceil(cm/50)*50; chart.options.scales.y.max=yMax; }
  if(t>xMax){ xMax=Math.ceil(t/10)*10;   chart.options.scales.x.max=xMax; }
}
function addPoints(t,raw,ma){
  if(!Number.isFinite(raw)) return;
  datasetRaw.data.push({x:t,y:raw});
  if(Number.isFinite(ma)) datasetMA.data.push({x:t,y:ma});
  chart.update('none');
}
function resetPlotOnly(){
  records.length=0;
  datasetRaw.data.length=0;
  datasetMA.data.length=0;
  maBuf.length=0;
  yMax=100; xMax=10;
  chart.options.scales.y.max=yMax;
  chart.options.scales.x.max=xMax;
  t0=performance.now();
  datasetMA.label=`MA${maN} (cm)`;
  chart.update();
}

/* ====================== 移動平均 ====================== */
function sma(v){
  maBuf.push(v);
  if(maBuf.length>maN) maBuf.shift();
  let s=0; for(let i=0;i<maBuf.length;i++) s+=maBuf[i];
  return s/maBuf.length;
}
function recomputeMAForAll(){
  maBuf.length=0;
  datasetMA.data.length=0;
  for(const r of records){
    r.ma=sma(r.raw);
    datasetMA.data.push({x:r.t,y:r.ma});
  }
  datasetMA.label=`MA${maN} (cm)`;
  chart.update();
}

/* ====================== Web Serial ====================== */
const btnConnect=document.getElementById('btnConnect');
const btnDisconnect=document.getElementById('btnDisconnect');
const btnStart=document.getElementById('btnStart');
const btnStop=document.getElementById('btnStop');
const btnReset=document.getElementById('btnReset');
const btnCsv=document.getElementById('btnCsv');
const hzNum=document.getElementById('hzNum');
const maNum=document.getElementById('maNum');
const modeSel=document.getElementById('modeSel');
const statusEl=document.getElementById('status');

function setStatus(s){ statusEl.textContent=s; }

async function sendLine(s){
  if(!writer) return;
  const enc=new TextEncoder().encode(s+"\n");
  await writer.write(enc);
}
class LineBreakTransformer{
  constructor(){ this.container=""; }
  transform(chunk,controller){
    this.container+=chunk;
    const lines=this.container.split(/\r?\n/);
    this.container=lines.pop();
    for(const line of lines) controller.enqueue(line);
  }
  flush(controller){ if(this.container) controller.enqueue(this.container); }
}

/* 数字だけの行（mm）を採用 */
function processLine(line){
  const s=line.trim();
  if(!/^-?\d+(?:\.\d+)?$/.test(s)) return;
  const mm=parseFloat(s);
  if(!isFinite(mm) || mm<0 || mm>4000) return;

  const raw=mm/10;            // cm
  const ma=sma(raw);
  const t=(performance.now()-t0)/1000;

  records.push({t,raw,ma});
  updateAxesIfNeeded(t, raw);
  addPoints(t, raw, ma);
}

async function startReading(){
  if(!port || reading) return;
  reading=true;
  setStatus('RUN');           // ← Start時に必ずRUNを表示
  t0=performance.now();

  const textDecoder=new TextDecoderStream();
  const closedReadable=port.readable.pipeTo(textDecoder.writable).catch(()=>{});
  const lineStream=textDecoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer()));
  reader=lineStream.getReader();

  try{
    while(reading){
      const {value,done}=await reader.read();
      if(done || !reading) break;
      if(value!==undefined) processLine(value);
    }
  }catch(_){/* ignore */}
  finally{
    try{ reader.releaseLock(); }catch(_){}
    await closedReadable.catch(()=>{});
  }
}

async function stopReading(){
  reading=false;
  try{ if(reader) await reader.cancel(); }catch(_){}
  setStatus('STOP');
}

/* ====================== UIイベント ====================== */
btnConnect.addEventListener('click',async()=>{
  try{
    port=await navigator.serial.requestPort();
    await port.open({baudRate:115200});
    writer=port.writable.getWriter();
    setStatus('CONNECTED');
  }catch(e){ alert('Serial接続に失敗: '+e); }
});

btnDisconnect.addEventListener('click',async()=>{
  try{ await sendLine('STOP'); }catch(_){}
  await stopReading();
  try{ if(writer){ writer.releaseLock(); writer=null; } }catch(_){}
  try{ if(port) await port.close(); }catch(_){}
  port=null;
  setStatus('DISCONNECTED');
});

btnStart.addEventListener('click',async()=>{
  if(!port){ alert('先にConnectしてください'); return; }
  const hz=Math.max(1,Math.min(50,Number(hzNum.value)||50));
  resetPlotOnly();                 // グラフ/バッファだけ初期化
  await sendLine(`START hz=${hz}`);
  startReading();
});

btnStop.addEventListener('click',async()=>{
  await sendLine('STOP');
  await stopReading();
});

btnReset.addEventListener('click',()=>{
  resetPlotOnly();                 // 読み取りは続行
  setStatus(reading ? 'RUN (RESET)' : 'RESET');
});

btnCsv.addEventListener('click',()=>{
  let csv="t_sec,raw_cm,ma_cm\n";
  for(const r of records) csv+=`${r.t.toFixed(3)},${(r.raw??'').toFixed(3)},${(r.ma??'').toFixed(3)}\n`;
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='vl53l0x_log.csv';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

maNum.addEventListener('change',()=>{
  const n=Math.max(1,Math.min(50,Number(maNum.value)||5));
  maN=n; maNum.value=n;
  recomputeMAForAll();
});

modeSel.addEventListener('change',applyMode);

/* ====================== 初期チェック ====================== */
if(!('serial' in navigator)){
  alert('このブラウザはWeb Serialに対応していません。Chrome/EdgeのHTTPSでお試しください。');
}
applyMode();         // 初期: 移動平均のみ
resetPlotOnly();     // 軸を初期化
</script>
</body>
</html>
